package handlers

import (
	"log"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"

	"codehustle/backend/internal/middleware"
	"codehustle/backend/internal/models"
	"codehustle/backend/internal/repository"
)

// ListProblems returns a list of problems
func ListProblems(c *gin.Context) {
	// Get user context to check if they're admin/lecturer (can see private problems)
	userCtx, exists := c.Get("user")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "missing_user_context"})
		return
	}

	// Check if user is admin or lecturer to show all problems
	isPublicOnly := true
	if userCtxVal, ok := userCtx.(middleware.UserContext); ok {
		log.Printf("[PROBLEM] User roles: %v", userCtxVal.Roles)
		for _, role := range userCtxVal.Roles {
			if role == "admin" || role == "lecturer" || role == "instructor" {
				isPublicOnly = false
				log.Printf("[PROBLEM] User has privileged role: %s, showing all problems", role)
				break
			}
		}
	}

	log.Printf("[PROBLEM] Query filter: isPublicOnly = %v", isPublicOnly)

	problems, err := repository.ListProblems(isPublicOnly)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "failed_to_fetch_problems",
			"message": err.Error(),
		})
		return
	}

	log.Printf("[PROBLEM] Found %d problems", len(problems))
	c.JSON(http.StatusOK, gin.H{"problems": problems})
}

// GetProblem returns a single problem by ID or slug
func GetProblem(c *gin.Context) {
	identifier := c.Param("id")
	if identifier == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing_problem_identifier"})
		return
	}

	problem, err := repository.GetProblem(identifier)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error":   "problem_not_found",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{"problem": problem})
}

// CreateProblemRequest represents the expected payload for creating a problem
type CreateProblemRequest struct {
	Title         string `json:"title" binding:"required"`
	Slug          string `json:"slug,omitempty"` // Optional, will be auto-generated from title if not provided
	StatementPath string `json:"statement_path" binding:"required"`
	Difficulty    string `json:"difficulty,omitempty"`
	IsPublic      bool   `json:"is_public"`
	TimeLimitMs   int    `json:"time_limit_ms"`
	MemoryLimitKb int    `json:"memory_limit_kb"`
}

// CreateProblem creates a new problem (admin/lecturer only)
func CreateProblem(c *gin.Context) {
	// Get user context
	userCtx, exists := c.Get("user")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "missing_user_context"})
		return
	}

	userCtxVal, ok := userCtx.(middleware.UserContext)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid_user_context"})
		return
	}

	// Parse request body
	var req CreateProblemRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "invalid_request",
			"message": err.Error(),
		})
		return
	}

	// Set defaults for optional fields
	timeLimitMs := req.TimeLimitMs
	if timeLimitMs == 0 {
		timeLimitMs = 2000 // Default 2 seconds
	}

	memoryLimitKb := req.MemoryLimitKb
	if memoryLimitKb == 0 {
		memoryLimitKb = 262144 // Default 256 MB
	}

	// Create problem model
	problem := models.Problem{
		ID:            uuid.NewString(),
		Title:         req.Title,
		Slug:          req.Slug, // Will be auto-generated by repository if empty
		StatementPath: req.StatementPath,
		Difficulty:    req.Difficulty,
		IsPublic:      req.IsPublic,
		TimeLimitMs:   timeLimitMs,
		MemoryLimitKb: memoryLimitKb,
		CreatedBy:     userCtxVal.ID,
	}

	// Create problem (slug will be auto-generated in repository if not provided)
	if err := repository.CreateProblem(&problem); err != nil {
		log.Printf("[PROBLEM] Failed to create problem: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "failed_to_create_problem",
			"message": err.Error(),
		})
		return
	}

	log.Printf("[PROBLEM] Created problem '%s' (ID: %s, Slug: %s) by user %s", problem.Title, problem.ID, problem.Slug, userCtxVal.ID)
	c.JSON(http.StatusCreated, gin.H{"problem": problem})
}
